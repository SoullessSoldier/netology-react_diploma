# Описание работ
[вернуться в корневой readme](../README.md)

* TOC

{:toc}

## Общие вопросы

### Окружение

Файл api.rest в папке бэка навел на мысль, что нужно установить расширение REST Client для VS Code, с этим плагином можно запускать запросы к бэку прямо в окне редактора с открытым файлом api.rest

[Вверх](#top)

### Правила хорошего кода

Требование про правила линтера airbnb отстало от современности - вышел ESLint 9 с новым форматом конфига и всё сломалось.  
Тем не менее, в проекте есть eslint с плагинами для реакта и prettier с рекомендованными и базовыми правилами соответственно.  
В VS Code включена настройка автоформатирования при выходе - "editor.formatOnSave": true  
Форматирование меняет код по правилам, eslint при запуске ругается на код, если ошибки есть, VS Code ошибки линтера подсвечивает.

Топик с SoF про airbnb: https://stackoverflow.com/questions/74925642/how-to-use-eslint-config-airbnb-with-the-new-eslint-config-spec

Команды для установки окружения:

```sh
cd frontend
npm create vite@latest .
npm i -D eslint eslint-plugin-react eslint-plugin-react-hooks
npm i -D vite-plugin-eslint
npm i -D prettier eslint-config-prettier eslint-plugin-prettier
```

```sh
cd backend
npm i
npm audit fix
```

ESLint & Prettier old stuff:

- https://dev.to/suprabhasupi/learn-to-configure-eslint-and-prettier-in-react-4gp0
- https://github.com/prettier/eslint-plugin-prettier
- https://prettier.io/docs/precommit
- https://dev.to/aolyang/eslint-9-flat-config-tutorial-2bm5
- https://react-v9.holt.courses/lessons/tools/linting
- https://store-restack.vercel.app/p/vite-knowledge-react-eslint-prettier-typescript
- https://www.geeksforgeeks.org/how-to-set-up-vite-with-eslint-and-prettier/
- https://dev.to/bushblade/add-eslint-to-a-react-vite-project-4pib
- https://eslint.org/docs/latest/use/configure/configuration-files#extending-configuration-files
- https://pkolt.ru/blog/eslint9/
- https://blog.logrocket.com/12-essential-eslint-rules-react/
- https://github.com/jsx-eslint/eslint-plugin-react
- https://www.robinwieruch.de/vite-eslint/
- https://eslint.org/docs/latest/use/getting-started
- https://www.freecodecamp.org/news/how-to-add-eslint-to-your-react-project/
- https://tproger.ru/articles/podgotovka-okruzhenija-react-prilozhenija-vscode-prettier-eslint-stylelint-husky
- https://habr.com/ru/articles/417841/
- https://github.com/airbnb/javascript
- https://github.com/airbnb/javascript/tree/master/react
- https://shaifarfan.com/blog/airbnb-eslint-prettier-setup-react-typescript/
- https://mwh-deploy.netlify.app/blog/react-eslint-airbnb-prettier
- https://stackoverflow.com/questions/71020035/setup-vite-template-react-and-eslint-airbnb

[Вверх](#top)


## Бэкенд

Бэкенд переписан на Python & Flask, ссылка на доку - [README](./README_backend.md)

[Вверх](#top)


## Фронтенд

Проект сделан на JS с помощью Vite.   
Принято решение использовать Redux/Redux Toolkit + Redux Saga для централизованного управления данными и обработки side-эффектов.  
Используются редьюсеры и саги, для каждой задачи свои.   
В проекте есть .env-файл, образец в *.env.sample.  

### Общие вопросы

#### Иконки для сайта

Создана favicon, сайт https://realfavicongenerator.net/

#### Bootstrap

В версиях Bootstrap5 и Bootstrap 4.3.1 (из проекта) есть различия, пришлось использовать ту версию, которая указана в проекте.  
Хотя надо обновляться хотя бы до 4.6.2 или мигрировать на v5.  
Не совсем понятно, зачем в исходнике html подключался FontAwesome, характерные классы в верстке я не нашел. 

#### Routing

С библиотекой react-router-dom@6 реализован роутинг - компоненты шапки сайта, баннера и подвала не перезагружаются, компоненты разных маршрутов отрисовываются внутри тега \<main\> с помощью элемента Outlet из баблиотеки роутинга.

#### Адрес бэкенда и эндпойнтов API
Адрес бэкенда описан в .env-файле.  
Адреса эндпойнтов описаны в файле @/backend_urls.js в проекте, в этом же файле используется адрес бэкенда из переменной окружения, которая формируется из .env-файла.


#### Обработка ошибок от сервера
В сагах использован оператор retry для повтора запроса к api в случае ошибки.  
Количество повторов и время между повторами запросов описано в .env-файле.  

В функции-обработчике запроса к api использован axios и его параметр конфига, отвечающий за максимальное время ожидание ответа от сервера.  
Пороговое время ожидания ответа от сервера также описано в .env-файле.

### Реализация приложения

#### Header

Реализовано появление/скрытие поля поиска при клике по иконке поиска.  
Реализован переход на страницу корзины при клике на иконку корзины.  
При переходе по любым маршрутам (при клике на NavLink), поле поиска скрывается и восстанавливается изначальное состояние.


#### Footer

В представленной верстке есть ошибка, ширина футера визуально больше, чем у хидера, исправил.  
Открытый адрес электронной почты - это подарок ботам и спамерам.


#### 404

Реализован компонент, отображающийся при переходе по неверному маршруту (404)


#### Хиты продаж


Из верстки выделен компонент карточки товара, обнаружены недостатки верстки, добавлены дополнительные классы.

Немного странно, но пришлось выполнять задание "необходимо распарсить и вывести элементы. Если в ответе пришёл пустой массив, то есть хитов продаж нет, то компонент не должен ничего отображать, как и не должен занимать места на экране", это породило дублирование верстки.


### Каталог
Каталог состоит из двух элементов, требующих своих сторов - меню категорий и список товаров

#### Категории
бэк отдает объекты категорий в массиве
[
  {
    "id": 12,
    "title": "Мужская обувь"
  },
]
В начальном состоянии есть объект {id: ALL_CATEGORY_ID, title: "Все"}, к нему добавляем ответ сервера.  
ALL_CATEGORY_ID = 99999, прописан в конфиге в @/config/configParams  
Клик по категории должен вести на страницу каталога с фильтрацией с выводом товаров из нужной категории.  
Считаем, что у нас в магазине заведомо не будет 99999 категорий товаров.

#### Каталог товаров

Основная работа в редьюсере, в сторе список не перезаписывается, а конкатенируется.  
Реализована переменная для признака того, отображать ли кнопку "Загрузить еще".  
По условию задачи бэк отдает по 6 объектов товаров в списке, но это количество я вынес в переменную в .env-файл.  
Реализована обработка кейса, когда при загрузке данных для каталога происходит сбой, который не устраняется автоматическими повторами запроса в саге, в таком случае вместо кнопки "Загрузить ещё"  отобразится кнопка "Повторить запрос" с аналогичным функционалом. Это проверено через консоль разработчика в браузере.

### Централизованная загрузка данных
По ходу реализации пришлось сделать централизованную загрузку данных для TopSales и Catalog в компоненте App.jsx, чтобы при переходе по разным маршрутам приложения не происходило лишних запросов к бэку, что может привести к дублированию данных.

### Поиск
При заполнении этого поля отправляется запрос вида: GET http://localhost:7070/api/items?q=<текст в строке поиска>.  
При этом все правила относительно категории кнопки «Загрузить ещё» сохраняются.

Если категория меняется, то данные перезагружаются с учётом строки поиска.

Строка поиска реагирует только на полный ввод, не live-поиск.
Минимальное количество символов для выполнения поиска - 3 - определено в атрибуте minLength элемента input

При  любой из категорий ввел строку поиска - пошел запрос с учетом категории, currentOffset, searchString

### Виджет поиска в шапке сайта
На всех страницах в шапке присутствует виджет поиска.
По умолчанию поисковое поле скрыто, отображается только иконка.  
Эта иконка должна работать следующим образом: при первом клике открывает строку поиска, при втором, если был введён какой-то текст, то перенаправляет пользователя на страницу каталога (/catalog.html), при этом в поисковом поле должен быть отображён тот же текст, что был ввёден в строку поиска в шапке, и загрузка данных должна происходить исходя из этого.

Немного усовершенствую логику - на странице Каталога функционал виджета поиска не нужен, так как строка поиска в Каталоге и так есть, т.е. логика открытия виджета должна работать на всех страницах, кроме Каталога.

Минимальное количество символов для выполнения поиска - 3 - определено в атрибуте minLength элемента input

### Страница товара
В ТЗ и исходнике html расхождения, по ТЗ маршрут /catalog/:id.html, а в html /products/:id.html, немного странный URL с добавкой ".html", но ОК.  

Ключевые моменты:
- При загрузке показывается лоадер.
- Для загрузки полной информации о товаре нужно сделать GET http://localhost:7070/api/items/:id, где id — это ID товара.
- Слева выводится картинка, в ответе может быть несколько картинок — вы берёте первую.
- Сбоку выводится табличка с данными, все необходимые данные перечислены. Других не нужно. Если каких-то в приходящем товаре не будет, то просто оставляете поле пустым.
- Размеры — выводятся все доступные размеры, у которых флаг available равен true. По умолчанию ни один размер не выбран. После выбора он становится выделенным, как на скриншоте. Важно: кнопка «В корзину» активируется только тогда, когда есть размеры в наличии и выбран конкретный размер. Размер можно выбрать только один.
- Количество — от 1 до 10.
- Особые случаи: если ни одного размера не доступно, блок «Количество» и кнопка «В корзину» не отображаются.
- После нажатия на кнопку «В корзину» пользователь перемещается в страницу корзины /cart.html.

### Корзина

Странно, что в ТЗ предусмотрено группировка товаров одной "единицы", но при этом нет требования о возможности изменения количества "единиц" товара. Т.е. положить в корзину несколько одинаковых товаров можно, при этом они будут сгруппированы, но удалить можно только всю группу.
Со стоимостью товара при операции с корзиной вообще серая зона - если в момент оформления заказа цена на сервере поменяется, то это надо валидировать и сообщать пользователю. Но в рамках этой работы я помещаю в стор и localStorage ту цену, которую вилит пользователь.  
Вообще нужна обработка юзеркейса, когда пользователь положил в корзину товар с одной ценой, на сервере успели поменять цену этого товара, пользователь захотел добавить еще одну единицу этого товара, но цена уже будет другая. В сторе поменяется только количество, а цена останется от ранее положенной в корзину единицы товара.  

Реализован виджет корзины для шапки сайта, у виджета отображается количество положенных в корзину товаров, виджет является ссылкой на страницу корзины.

Для работы с localStorage нужно определить имя ключа, поэтому  в .env-файл добавлена переменная VITE_LOCAL_STORAGE_KEY

Для отслеживания изменений в корзине и записи в localStorage пытался прикрутить хуки, но столкнулся с нежелательным поведением при открытии и закрытии страницы приложения. В итоге решил, что запись в localStorage это side-effect для экшенов стора Корзины, поэтому использовал сагу.

**Форма отправки собирает номер телефона - с 30 мая 2025 года хозяин такого сайта будет считаться оператором Персональных Данных.**
**На сайте разместил ссылку на страницу Политики обработки персональных данных**

#### Отправка заказа

На странице корзины присутствует компонент CartOrder. Для этой задачи сделан отдельный стор order для хранения статуса ответа сервера.  
Реализован сбор контактных данных от заказчика. После отправки для анимации ожидания ответа от сервера отображается прелоадер.  
После получения ответа от сервера (бэк отдает статус 204 и пустой ответ, так что в саге я подменяю пустое значение на "OK") компонент ведет себя так:
- если ответ от сервера успешный, то форма заказа скрывается, появляется сообщение об успехе, через 3 секунды оно скрывается, очищаются сторы корзины и заказа,
- если ответ о сервера с ошибкой, то форма заказа остается (но на 3 секунды кнопка отправки неактивная), появляется сообщение об ошибке, через 3 секунды оно скрывается, очищается только стор  заказа.

Таймаут в 3 секунды и то, что форма остается на странице при сбое (помимо того, что в сагах есть функционал повторного вызова функции, которая обращается к api)- это ответ на вопрос "Каким образом отображать сообщения об ошибке, чтобы либо автоматически, либо с помощью пользователя чуть позже повторно выполнить запрос без полной перезагрузки страницы?" 

Ответ на вопрос про хранение чувствительной информации на стороне пользователя:
- лучше вообще не хранить персональные данные на стороне клиента,
- шифровать данные, которые записываются в sessionStorage/localStorage,
- использовать HTTP-only cookie (но это надо предусматривать на сервере),
- использовать протокол HTTPS и включать HSTS (запрещать браузеру использовать HTTP).

### Деплой
Используем хост на Github Pages, применим классический подход, но надо бы посмотреть на Github Actions  
https://blog.logrocket.com/gh-pages-react-apps/

[Вверх](#top)






